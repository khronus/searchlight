package genjs

import (
	"bytes"
	"fmt"
	"github.com/golang/glog"
	"github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway/descriptor"
	"strings"
	"text/template"
	"unicode"
)

type binding struct {
	*descriptor.Binding
	Path       string
	DeleteVars []string
	BodyVar    string
	ParamVar   string
}

const paramVar = "p"

func jsGetter(fieldPath string) string {
	js := paramVar
	for _, f := range strings.Split(fieldPath, ".") {
		js += ("['" + f + "']")
	}
	return js
}

func jsPath(path string) (string, []string) {
	if path == "" {
		return "", []string{}
	}

	const (
		init = iota
		field
		nested
		restart
	)
	var st = init

	deleteList := make([]string, 0)
	var url, del bytes.Buffer
	url.WriteString(`'`)
	for _, r := range path {
		switch st {
		case init:
			if r == '{' {
				url.WriteString(`' + ` + paramVar + `['`)
				del.WriteString(paramVar + `['`)
				st = field
			} else {
				url.WriteRune(r)
			}
		case field:
			if r == '.' {
				url.WriteString(`']['`)
				del.WriteString(`']['`)
			} else if r == '=' {
				url.WriteString(`']`)
				del.WriteString(`']`)
				deleteList = append(deleteList, del.String())
				del.Reset()
				st = nested
			} else if r == '}' {
				url.WriteString(`']`)
				del.WriteString(`']`)
				deleteList = append(deleteList, del.String())
				del.Reset()
				st = restart
			} else {
				url.WriteRune(r)
				del.WriteRune(r)
			}
		case nested:
			if r == '}' {
				st = restart
			}
		case restart:
			if r == '/' {
				url.WriteString(` + '/`)
				st = init
			}
		}
	}
	if st == init {
		url.WriteString(`'`)
	}
	return url.String(), deleteList
}

func (g *generator) applyTemplate(file *descriptor.File) (string, error) {
	w := bytes.NewBuffer(nil)
	if err := headerTemplate.Execute(w, file); err != nil {
		return "", err
	}
	var methodSeen bool
	for _, svc := range file.Services {
		httpMethods := make([]*descriptor.Method, 0)
		for _, meth := range svc.Methods {
			glog.V(2).Infof("Processing %s.%s", svc.GetName(), meth.GetName())
			methodSeen = true
			for _, b := range meth.Bindings {
				path, delVars := jsPath(strings.TrimPrefix(b.PathTmpl.Template, g.reg.Prefix))
				bind := binding{
					Binding:    b,
					Path:       path,
					DeleteVars: delVars,
					ParamVar:   paramVar,
				}
				if b.Body == nil {
					bind.BodyVar = "null"
				} else if b.Body.FieldPath.String() == "" {
					bind.BodyVar = paramVar
				} else {
					bind.BodyVar = jsGetter(b.Body.FieldPath.String())
				}
				if err := handlerTemplate.Execute(w, bind); err != nil {
					return "", err
				}
				httpMethods = append(httpMethods, meth)
				break
			}
			svc.Methods = httpMethods
		}
	}
	if !methodSeen {
		return "", errNoTargetService
	}
	if err := trailerTemplate.Execute(w, file); err != nil {
		return "", err
	}
	return w.String(), nil
}

func ToLoweCamel(s string) string {
	if s == "" {
		return ""
	}
	rs := []rune(s)
	rs[0] = unicode.ToLower(rs[0])
	return string(rs)
}

func ToPkgPath(pkg *string) string {
	s := "services"
	if pkg != nil {
		parts := strings.Split(*pkg, ".")
		for i := len(parts) - 1; i >= 0; i-- {
			s = fmt.Sprintf("{%v: %v}", ToLoweCamel(parts[i]), s)
		}
	}
	return s
}

var (
	headerTemplate = template.Must(template.New("header").Parse(
		`// Code generated by protoc-gen-grpc-js-client
// source: {{.GetName}}
// DO NOT EDIT!

/*
This is a RSVP based Ajax client for gRPC gateway JSON APIs.
*/

var xhr = require('grpc-xhr');
`))

	funcMap = template.FuncMap{
		"ToLowerCamel": ToLoweCamel,
		"ToPkgPath":    ToPkgPath,
	}

	handlerTemplate = template.Must(template.New("handler").Funcs(funcMap).Parse(`
function {{.Method.Service.GetName | ToLowerCamel }}{{.Method.GetName}}({{.ParamVar}}, conf) {
    path = {{.Path}}
    {{- range $delVar := .DeleteVars}}
    delete {{$delVar}}
    {{- end}}
    {{- if .Body}}
    {{- if .Body.FieldPath}}
    body = {{.BodyVar}}
    delete {{.BodyVar}}
    return xhr(path, '{{.HTTPMethod}}', conf, {{.ParamVar}}, {{.BodyVar}});
    {{- else}}
    return xhr(path, '{{.HTTPMethod}}', conf, null, {{.ParamVar}});
    {{- end}}
    {{- else}}
    return xhr(path, '{{.HTTPMethod}}', conf, {{.ParamVar}});
    {{- end}}
}
`))

	trailerTemplate = template.Must(template.New("trailer").Funcs(funcMap).Parse(`
var services = {
{{- range $svc_idx, $svc := .Services -}}
    {{if $svc_idx}},{{end}}
    {{$svc.GetName | ToLowerCamel}}: {
        {{- range $m_idx, $m := $svc.Methods -}}
        {{if $m_idx}},{{end}}
        {{$m.GetName | ToLowerCamel}}: {{$svc.GetName | ToLowerCamel}}{{$m.GetName}}
        {{- end}}
    }
{{- end}}
};

module.exports = {{.Package | ToPkgPath}};
`))
)
